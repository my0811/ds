package com.yang.ds.algorithm.recursion;


/**
 * 递归实现乘方
 * x^y =(x^2)^y/2 (y为偶数)
 * x^y=(x^2)^y/2*x(y为奇数)，因为int类型奇数的话会有小数问题，会舍弃小数，就会少一次乘方，所以需要在乘一次底数
 * 开动小脑瓜思考一下，为什么换算成上面的等式来玩呢？就是方便递归，当y不断的折半缩减，x也在不断的在原来基础上继续乘方
 * 底数原来的基础上增加括号外的一次平方，最外面的y的次方数就除2所以最终当y趋近与1和0的时候，所有的平方也就计算完成了，直接
 * 从递归的最底层一直返回到第一次调用的地方，然后返回，方法结束，返回了最终得平方计算
 * <p>
 * 继续加油，递归的思想又进一步的理解，膜拜搞算法的这些大神
 */
public class Involution {
    public static void main(String[] args) {
        System.out.println(pow(2, 3));
    }

    public static int pow(int x, int y) {
        //边界值判断,出现y=0只能是已经乘方到最后一位了，然后越界了，这个时候上一个步骤一定是奇数(1)，所以返回1就是放回上一步的乘方值
        // 恰巧这个也是数学上本来应该情况相互吻合，因为任何数0次方都是1
        if (y == 0) {// 出现这种情况只能是已经到了1次方的时候了，又递归了一次，不可能出现的情况，出发没有加上下面那个判断条件
            return 1;
        }
        if (y == 1) {// y=1代表所有乘方都已经完成了，把累计的x所有的乘方的值可以直接返回了
            return x;
        }
        if (y % 2 == 1) {// 奇数
            return pow(x * x, y / 2) * x;
        } else {//偶数
            return pow(x * x, y / 2);
        }
    }
}
