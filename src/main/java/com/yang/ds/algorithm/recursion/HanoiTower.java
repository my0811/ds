package com.yang.ds.algorithm.recursion;


/**
 * 汉诺塔问题，递归的入门思想，也是java栈结构的执行流程，很适合你理解递归
 *  -   1 |   |
 *  --  2 |   |
 * ---  3 |   |
 *  A     B   C
 * 小故事:
 *于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。
 * 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
 * 并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘
 * 当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。
 *
 * 当然，只要有点脑子的都会想一想他的预言是否是真的呢？世界真会毁灭？还是大神是坑人的，是一个根本不能完成的任务呢？
 * 这种移动方法，需要2^64-1的移动步骤，加入每次移动耗费一秒中，那将是18446744073709511615秒，换算成年的话，将是
 * 5845.42亿 年，地球才存活多少年啊哥们，这么长时间，地球早就灰飞烟灭了，计算机能完成吗？这么大的指令对于计算机来讲
 * 也是不可能完成的任务，就算是计算机是毫秒级别的，一毫秒移动1次，那也不可能完成的也需要几亿年
 *
 * 所以说，一个算法的复杂度在logN的作用，如果是存储了这么多数据，如果是线程O(N)的方式查找数据，计算机不可能完成
 * 但是如果是采用二分查找，则不然，需要64次即可定位，所以B+B树才会应运而生，数据完全可以到达这个级别，但是如果没有
 * 索引，海里捞针，那将是不可能完成的任务
 *
 *
 * 解决思路：
 * 1. 一个盘子可以看做是A-C的问题
 * 2. 两个盘在可以看做A-B-C的问题, A-B ,A-C,B-C
 * 3. 三个盘子的问题，就可以看做是两个盘子的问题,两个盘子到B，第三个盘子到C，B上的两个盘子到C，B上两个盘子到C
 * 则有可以看做是两个盘子到C的过程，只不过B相当于A，A相当于B
 * .... 递归，三个盘子看成2+1,四个盘子看成3+1，n个盘子看成n-1+1
 *
 * 所以每次处理都需要一个中转的柱子，这个柱子就像两个盘子的解决一样，A-C，则B是中转，A-B则C是中转，B-C则A是中转
 * A,B,C 都看做是两个盘子移动到C,B作为中转一样的
 *
 *
 * */
public class HanoiTower {

    private static int sc = 0;

    public static void main(String[] args) {
        /**
         * -   1 |   |
         * --  2 |   |
         * --- 3 |   |
         * A     B   C
         * */
        hanoi(4, "A", "B", "C");
    }

    /**
     * 递归实现汉诺塔问题，
     * 1.其实把汉诺塔的问题，看做成是一个两个盘子的移动的问题，然后不断的递归
     * 2.换图剖析代码的执行流程
     */
    public static void hanoi(int dish, String A, String B, String C) {
        System.out.println(A + B + C);
        // 递归边界值，如果为1的时候，就是一个盘子的问题，直接从A到C
        if (dish == 1) {
            System.out.println("边界？");
            move(dish, A, C);
        } else {
            /**
             * 分治思想，
             * 1.底层如果移动到C,上一层不需要移动到B
             * 2.递归上层如果想移动到B，上面还有盘子就要移动到C，这样移动C完成底层才能移动到B
             * 3.递归再上一层，因为底层要移动到C，更上一层就要移动到B，
             * .... 周而复始，递归处理
             * 双递归函数，每个字部分都是先移动上面，然后再把自己移动到目标位置，然后再把中转的位置移动到目标位置
             *
             * */
            hanoi(dish - 1, A, C, B);//N-1个盘子由A经过C到达B
            move(dish, A, C);
            hanoi(dish - 1, B, A, C);//N-1个盘子由B经过A到达C
        }
    }

    private static void move(int dish, String from, String to) {
        sc++;
        System.out.println("step" + sc + " move(" + dish + ") " + from + "--->" + to);
    }
}
