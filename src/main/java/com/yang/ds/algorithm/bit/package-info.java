/**
 * ----二进制位，及二进制位运算，知识点--------------
 *
 * 1.第几位的最大值就是，k^位数-1,eg:10进制三位数最大值(10^3-1,1000-1(四位数最小值-1，因为右进位的临界值))
 *
 * 2.K进制的多少次平方，就是多少个K进制位的组合eg 16进制为2^4,四个二进制位(最大值15),如：1000进制肯定是10^3，因为10^3是1000，且最大值就是k^n-1
 * 但是只需要3位来保存，因为最大值999，在进位就已经到1000了，所以这个次方数就是需要的k进制的位数组合
 * n进制的k进制组合位数=log(k) n
 *
 * 3.无论是哪一位代表的值都是 当前位数的值*k的当前位数-1次方(位数从1开始), m*k^(i-1) i>=1
 *
 * 4.java的byte类型为啥是+128-1到-128
 * (1)为什么说存在有符号位移，就是因为最高位是保存符号的，0表示正数，1表示负数，以此类推，16位，32位，64位
 *
 * (2).正数:因为byte是8个bit位，最高位存储符号位,还有7位，所以第七位的最大值就是2^7-1(看上面的"1"中的结论)
 *
 * (3).因为计算机底层存储的数据都是二进制数据的补码,方便计算机进行符号运算，可以把减法当做加法运算，减少底层复杂度
 * 两个数相加=a-b= a补+(b补)，然后再取反
 * 原码：二进制数本身
 * 反码:正数还是其本身,负数是绝对值取反(就是除去符号位)
 * 补码:正数还是其本身,负数是反码(绝对值取反)+1,+1是为了解决-0的问题(看下面的补码推论)
 * +1是为了解决一个数的相反数，如果单纯用反码计算，符号位计算最终是1，其他位相加也全是1
 * 然后符号位不变取反，会出现100000,"-0"的情况，所以出现了补码，也就是反码+1,-0的情况就会因为多加一个1而进位，从而舍弃
 * 溢出的一位，最高位变成0解决了"-0"的问题，这是一个极限值
 *
 * ps:重点，补码的计算机表示
 *                   2^7-1     1
 * 1.正数最大值与最小值:0 1111111,00000001,(因为正数补码还是本身)
 *                   -2^7       -1
 * 2.负数最大值与最小值:1 0000001,1 1111111 负数的补码是绝对值取反+1(符号位是1，出去符号位的其他7个位是绝对值)
 *
 * 3.0的表示: 0 0000000
 *
 * 4.-0 10000000  因为我们看到了负数上面的最大值最小值，都能通过补码表示，但是-0的表示，相当于正常树一定不会出现的一种表示方式，所以规定这个树
 * 代表这个2^n,相当于比正数多一个表示,比如127，-128，负数多表示一个就是这么来的，-0是因为如果负数的补码没有+1的情况，只是用反码的话，比如
 * 1-1=1+-1=0 0000001+ 1 1111110=1 1111111，取反=10000000 =-0，但是如果负数的补码+1,则正好进位把符号位1顶掉，变成0，所以才有负数的补码为反码+1
 * 所以说-0是这么来的，否则刚才上面已经讨论了有效位的最大值，和最小值，负数都能表示的开，也就是8bit最大值127，和最小值1，都能表示成负数，但是这个-0正好是多出来的一个
 * 所以可以多表示一个，计算机规定这个就能表示2^n的数,n为有效值位数(除符号位,eg:32为最大有效值为是31，最高位是符号位)
 *
 * 结论:
 * "-0"的情况，作为补码永远不会出现，任何正数或者说是1111111(最高位1表示负数,7个1)的情况对应的补码10000001，越大则越小
 * 但是不会出现10000000的情况（-0才可以这么表示，-0没有意义，直接表示成0即可），所以说这个不会出现的"-0"计算机就定义了-128，所以可以多表示一个数
 *
 * ps:10000000的这种情况只可能是两个正数相加才会出现的，单独表示一个负数的补码，永远不会出现
 *----小计--------------
 *
 *
 *
 *
 *  计算机位运算
 * ________________________________________
 * I.进制的转换
 * <p>
 * k进制与10进制的转换（以k为基数的k进制）
 * (1)把k进制数a(共有n位)化为十进制数b的算法如下:
 * 第一步,输入a，k和n的值
 * 第二步,将b的值初始化为0，i的值初始化为"1"，从1开始，十进制中常说的个位
 * 第三步,b=b+a(i)*k^(i-1)
 * 第四步，判断i>n是否成立，若是，则执行第五步,否则返回第三步
 * 第五步,输出b的值
 * 总结:其实就是我们数学中10进制也是这样算,比如100，是一个三位数,所以n=3,k=10,i-1=[0,2]
 * 100=0*10(1-1)+0*10^(2-1)+1*10(3-1)=100
 * <p>
 * ________________________________________
 * II.十进制数转换成K进制的数字(除k取余法)
 * <p>
 * 第一步,给定十进制正整数a，和需要转换后的数的进制数基数k
 * 第二步,求出a除以k所得到的商"q",余数"r"
 * 第三步，把得到的余数依次"从右向左"(也就是从个位开始向左写)排列
 * 第四步,若q≠0,则a=q，返回第二步;否则输出全部的余数r的"排列"得到k进制数(直到商为0才停止)
 * 注意：第四步判断是在第二步和第三步完成之后的判断，也就是说如果商为0的那一次运算得到的余数，也要算上
 * eg:
 * 104转换为3进制的数
 * step1:
 * 104/3  34 2  ---->2
 * step2:
 * 34/3   11 1  ---->12
 * step3:
 * 11/3   3  2  ---->212
 * step4:
 * 3/3    1  0  ---->0212
 * step5:
 * 1/3    0  1  ---->10212
 * END (商已经为0了，game over)
 * ________________________________________
 * III.(二进制数转换10进制)
 * <p>
 * 高位降级法(NB的心算口诀)
 * 1. 十进制的举例 101 =1. 1*10+0=10 2. 10*10+1=101
 * 2. 二进制举例
 * <p>
 * 1100(12)
 * 1*2+1=3
 * 3*2+0=6
 * 6*2+0=12
 * <p>
 * 110(6)
 * 1*2+1=3
 * 3*2+0=6
 * <p>
 * 101(5)
 * 1*2+0=2
 * 2*2+1=5
 * _________________________________________
 * IIII(二进制和十六进制转换)
 * 1. 二进制和十六进制的转换 (A(10),B(11),C(12),D(13),E(14),F(15))
 * 2. 16进制数相当于是4个2进制位
 * 3. 16进制是2^4 四位二进制位 32进制数为2^5, 2^n进制数为n个二进制位log2^n位二进制位(省略2的底数)
 * 如下一串二进制数转换16进制的过程:
 * 1 0 0 1 0 1 1 0 0 (十进制 300)
 * <p>
 * 不足位补0
 * ------
 * 0 0 0  1|0 0 1 0|1 1 0 0
 * ------
 * <-------><-------><------->
 * 1         2        c
 * <p>
 * ------> ox12c  16进制数
 * ________________________________________
 * IIII.(补码)
 * 机器数:一个数在计算机中的表现形式叫做机器数，这个数有正负之分,最高位表示符号，0整1负
 * 真数:计算机中的机器数对应的真实的值就是真数
 * 原码: 用第一位表示符号，其余位表示值。因为第一位是符号位
 * 反码:正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反(也就是绝对值取反)
 * 1. 数在计算机底层是以补码的形式存储的
 * 2. 最左边的第一个二进制位表示符号位 "0"表示正数，"1"表示负数
 * 3. 正数的补码和源码是一样的,负数的补码表示，负数的(绝对值)二进制位按位取反(反码)再加1 "1.绝对值(除符号位的其他位),2.按位取反,3.加1"
 * 4. 使用补码是因为节约硬件的设计成本，只有加法，不用实现减法,用加法代替减法
 * 5. 符号位也参加运算
 * <p>
 * 举例推理:
 * 假设字节长度为为8bits
 * 一.使用原码相加
 * <p>
 * eg1:
 * (1)-(1)=1+(-1)
 * 00000001     +
 * 10000001
 * ________
 * 10000010       -----> -2 结果错误
 * <p>
 * eg2:
 * (1)-(2)=1+(-2)
 * 00000001    +
 * 10000010
 * ________      ------> -3 结果错误
 * 10000011
 * 所以上面计算如果是正数计算是正确的，但是负数计算就变成了绝对值相加然后再加个"负号"
 * 二.使用反码相加(反码，符号位不变)
 * 注意：反码，符号位不变
 * 推论1:
 * (1)-(1)=(1)+(-1)
 * 1)
 * -1的反码:
 * 10000001  按位取反(注意符号位不动)
 * ________
 * 11111110
 * 2) 1+(-1)反
 * 00000001  +
 * 11111110
 * _________
 * 11111111
 * 3)结果再取反
 * 11111111
 * ________
 * 10000000    ------>(-0)结果错误
 * 推论2:
 * (1)-(2)=(1)+(-2)
 * 1) -2的反码
 * 10000010  反
 * ________
 * 11111101
 * 2)
 * (1)+(-2)反
 * 00000001  +
 * 11111101
 * ________
 * 11111110
 * 3)结果取反
 * 11111110 反
 * ________
 * 10000001    -----> -1 我擦结果竟然神奇的对了
 * 同理：1-3=1+(-3)  -----> -2 结果也是正确的
 *
 * 分析,用反码相加其实就是-0的问题，那么加上1不就可以了吗？这样引出了补码的定义
 * 负数的补码=|二进制负数|-->取反-->+1
 * 所以两个数相减，就是加上被减数的补码
 * 再次证明 (1)-(1)
 *
 * 结论，计算机可以用补码的形式进行加减运算
 * 1. 正数的补码还是原码本身(规定)
 * 2. 负数的补码就是负数绝对值取反+1（绝对值，对于二进制来说就是除了符号位后面的数值部分，就是这个二进制数的绝对值）
 * eg 10000001 绝对值就是除了第一位符号位后面的所有二进制位就是绝对值(0000001=1),
 * 所以说绝对值取反，就是带着原来的符号位不变，符号位后面的全都取反
 * 两个数的加减可以表示成
 * a补+b补
 * (1)-(1)=
 * (1)+(-1)=
 * (1)补+(-1)补=
 * 00000001+11111111(100000001反+1)=
 *  00000001 +
 *  11111111
 *  --------
 * 100000000  -----> (0) 多近了一位，因为最多存储为8位，最高位移除舍弃，所以最终结果为0正确，所以补码解决了-0的问题
 *
 * 2-1，2+（－1）＝1，超出去的位数就舍弃了
 * 00000010
 *
 *
 * ____________________________________________________
 * 位运算
 *
 *
 * 一：
 *  System.out.println(Integer.MAX_VALUE << 1);
 *  这个值为-2，因为有符号左移，如果溢出，就相当于最高位把符号位顶掉了，-2就是因为全是1，开头是1表示负数，最后一位因为左移变成了0，会变成一个负数的补码形式了，
 *  如果这个补码-1，（第二位会变成0，其他所有位都是1）然后再取反，就是反码逆运算，得出了绝对值就是2，所以说java中的<< 如果溢出，则不管符号位了
 *  我们要事先知道数字多少位，判断有没有溢出，如果是负数就肯定是溢出了
 * 二：（注意一定是无符号右移，一律补0，因为或运算0不影响，但是如果补充1就出问题了）
 *    int n = 10;  // 最高位肯定是1啊，除了0是无效位
 *    n |= n >>> 1;// 除了无效位肯定都是有效位，右移动一位,变成了2个"1"
 *    n |= n >>> 2;// 原基础上在移动两位，变成了4个"1"
 *    n |= n >>> 4;// 原基础上已经4个"1",需要在移动4位变成了8个"1"
 *    n |= n >>> 8;// 再移动8个"1"变成16个"1"
 *    n |= n >>> 16;//在移动16个"1"，刚好填满32位
 *  1. 当然n的最大值也就是31个1组成的，从存在1的有效位不断的向右移动，最终会把最高的有效值最高位之后的所有位都变成1，都变成1之后无论移动多少位，或的值都是上一次全是1的值
 *  2. 当然如果n没有31位那么多，可能就是从第四位开始有效位是1，那么无论移动16还是8，只有最后为后面的四位都是1了，就不会再变了
 *  3. 这样做的好处就是能把n转换成和自己贴近的最小的2^n-1的二进制数,就是从有效位的最高位一直到最后一个为都是1，这样可以方便做低位与运算
 *  hashMap中有用位运算代替取模，都需要要求数组的长度是2^n次方，所以这段代码也是借鉴
 *
 * 三：
 * << 左移n位，末尾补0， *2^n，不区分符号，溢出则就是最挤掉最高位原来的值，用现在最高位的值替换
 *
 * >>右移，/2^n 向下取整,相当于把末位的余数干掉了，肯定是向下取整
 * 前面根据符号来定，如果是正则补0，如果是负数则补1，因为负数存的是补码，就是反码+1,所以最后，获取的时候还需要-1取反，高位补1即是补0，一个道理
 * 右移，需要不断的阉掉末尾数，如果末尾数不是0，说明有有余数，就不是2进制的正数倍，或者n次方，就会出现小数，但是32位都是表示正数的组合，干掉一位，就相当于向下取整了
 * int类型的32所表示的正数没有小数也就是这样，没有表示小数的位
 *
 * 四:
 * ">>>","<<<" 无符号右移，没有符号左移,
 *
 * 只有无符号右移，没有左移，这种操作也是逻辑位移动，不管高位的符号，一律用0补充空位,这种用法只是左位运算用，不用来表示数值的运算
 * 因为没有意义，负数的话移动就变成了正数
 *
 *
 *
 *
 *
 *
 * 二进制存储为啥是1024的倍数，因为1024是2^10,也就是我们10进制中常用的比如:米，千米，1米是10^1分米，1分米是10^1厘米，一千米又是10^3米，都是用进制的平方来的，但是二进制
 * 比较小，为了计算方便，用2^10次方来代表，因为二进制最小奇数是2，如果用10进制为技术，那么bit为的2进制会有整除不开的情况，没法把一个大的单位最终转换成是多少bit，一bit是一个2进制相当于
 * 10进制中的10一样，就尴尬了
 *
 *
 */
package com.yang.ds.algorithm.bit;
