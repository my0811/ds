package com.yang.ds.algorithm.bit;

/***
 *
 * 位运算(这个算法很有意思)
 * 利用位运算取有效位可以实现数组下标的循环 (获取四位有效位也是16进制，最多获取0-15)
 * 自己的理解:
 *
 * 1. 为什么jdk中使用这个取模运算，定义的数组长度是16的倍数(也就是2的n次方)?
 * 看下面二进制数：
 * 00001111(十进制15)，00010000（十进制16）
 * 到这里面就明白了吧 16-1正好是数组的下标最大值，并且最最最重要的是这个数的二进制低位是1111
 * "1111" 这个东西做&运算用处很大，可以取最低的四个有效位,并且有效值的最大值就是1111
 *
 *  2. 为什么这种算法会出现循环，看起来很牛逼的样子呢？
 * 再举一个例子，比如拿我们10进制的数来讲,我们用十进制的一个数的"个位数"作为数组的下标,那么数组下标就是[0-9],
 * 聪明的你现在肯定已经明白了，如果一个数不断的自增或者增加,又有啥毛线关系呢？个位数一直都是0-9的变化着，如果是每次自增1那么0-9的数组每次都是均匀的变化
 * 0->0 1 2 3 4 5 6 7 8 9 10 (1-0) 这个规律就是进制的最简单的特点，到了最大值又开始回归到最小值了，然后不断循环(任何数如果大于进制对应的最大值都是这个数倍数，余数则就是末尾进制的数)
 * 所以说这个算法巧妙之处就是利用了进制的这个特点，虽然进位了，但是我只关心最后四位,所以最后四位的最大值就是 （0-1111）之间不断的循环
 *
 * 3.负数也没问题吗？(根符号没有毛线关系了，支取低位，也不管符号位)
 * 当然没啥子问题了嘛，负数计算机存储的是补码，（取反+1） 所以撒，负数&1111和正数正好相反，无论负数如何变化，不看最高位的符号，值关注最低的有效位也逃脱(不要想太多，负数也是数，最后几位也长那样，就是最高位符号位是1而已)
 * 不了1111(16进制4bit位的最大值2^4-1)
 *
 * 4.有效位位与运算代替取模运算，实现循环数组
 *
 * 位的与运算的可以代替取模运算,提升运算效率，直接进行在二进制位上
 * 重要的两条概念需要记住，推导的话，就根据10进制来证明一下
 * 1. 一个K进制数，他的第n位的最大值M=k^n-1,并且k^n对应的位数=n+1
 * 2.任何n位的余数，都是最后n位的值，除非最后n位的值为0，则余数也为0，eg10^3为1000，那么最大与树在0,999(3次方，三个十进制位)
 *
 * 由1中的定理可以知道，我们为毛线定义数组长度是2^n，这样最大值-1，就是n个二进制位上所有的值都是1，方便左与运算，获取n个二进制位上的有效值，作为余数，代替取模
 * （1）.定义数组第一个开始坐标是0（很有用，也用的恰到好处,余数的最小值）最后一位为数组长度-1（余数的最大值）,取模整除，或者最后n位的值为0，都刚好是数组长度的整数倍，放到数组第0个位置
 * （2）.如果取模不是0说明有余数，也正好就是最后n位的值，这个余数或者最后n位对应的值就是数组0下标到数组长度-1的所有索引位置对应的存放数据
 * 的位置
 *
 *
 * */
public class BitOperation {

    public static void main(String[] args) {
        /**
         * 注意，这个里面这个里面是15位边界，如果一个数组长度是16，那么这个值正好是数组下标的循环，永远也不会越界
         *
         * */
        System.out.println("_____________负数_______________");
        for (int i = -1; i >= -19; i--) {
            System.out.print((i & 15) + " ");
        }
        System.out.println();
        System.out.println("_____________正数_______________");
        for (int i = 19; i >= 0; i--) {
            System.out.print((i & 15) + " ");
        }
        System.out.println();
    }
}
