package test.ds.recursion;

import org.junit.Test;

/**
 * 汉诺塔问题，递归的入门思想，也是java栈结构的执行流程，很适合你理解递归
 *  -   1 |   |
 *  --  2 |   |
 * ---  3 |   |
 *  A     B   C
 * 小故事:
 *于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。
 * 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
 * 并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘
 * 当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。
 *
 * 当然，只要有点脑子的都会想一想他的预言是否是真的呢？世界真会毁灭？还是大神是坑人的，是一个根本不能完成的任务呢？
 * 这种移动方法，需要2^64-1的移动步骤，加入每次移动耗费一秒中，那将是18446744073709511615秒，换算成年的话，将是
 * 5845.42亿 年，地球才存活多少年啊哥们，这么长时间，地球早就灰飞烟灭了，计算机能完成吗？这么大的指令对于计算机来讲
 * 也是不可能完成的任务，就算是计算机是毫秒级别的，一毫秒移动1次，那也不可能完成的也需要几亿年
 *
 * 所以说，一个算法的复杂度在logN的作用，如果是存储了这么多数据，如果是线程O(N)的方式查找数据，计算机不可能完成
 * 但是如果是采用二分查找，则不然，需要64次即可定位，所以B+B树才会应运而生，数据完全可以到达这个级别，但是如果没有
 * 索引，海里捞针，那将是不可能完成的任务
 *
 *
 * 解决思路：
 * 1. 一个盘子可以看做是A-C的问题
 * 2. 两个盘在可以看做A-B-C的问题, A-B ,A-C,B-C
 * 3. 三个盘子的问题，就可以看做是两个盘子的问题,两个盘子到B，第三个盘子到C，B上的两个盘子到C，B上两个盘子到C
 * 则有可以看做是两个盘子到C的过程，只不过B相当于A，A相当于B
 * .... 递归，三个盘子看成2+1,四个盘子看成3+1，n个盘子看成n-1+1
 *
 * 所以每次处理都需要一个中转的柱子，这个柱子就像两个盘子的解决一样，A-C，则B是中转，A-B则C是中转，B-C则A是中转
 * A,B,C 都看做是两个盘子移动到C,B作为中转一样的
 *
 *
 *
 *
 *
 *
 *
 * */

public class HanoiTower {
    int step;

    @Test
    public void hanoiTest() {
        hanoi(3, "A", "B", "C");

    }

    private void hanoi(int dish, String A, String B, String C) {
        if (dish == 1) {
            move(A, C);
        } else {
            hanoi(dish - 1, A, C, B);
            move(A, C);
            hanoi(dish - 1, B, A, C);
        }
    }

    private void move(String a, String c) {
        System.out.printf("move from %s to %s", a, c);
        System.out.println();
    }


}


